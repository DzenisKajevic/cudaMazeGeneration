#include <curand_kernel.h>
#include <iostream>

#define N 21  // Size of individual mazes (N x N)
#define P 2  // Number of mazes in one row/column of the large maze
#define MAX_SIZE (N * N)
#define DEBUG_THREAD_ID 0  // Thread ID to debug

// (N*P)*(N*P)

#define cudaCheckError() {                               \
    cudaError_t e = cudaGetLastError();                    \
    if (e != cudaSuccess) {                                \
        printf("CUDA Error %s:%d: %s\n", __FILE__, __LINE__, cudaGetErrorString(e)); \
        exit(EXIT_FAILURE);                                \
    }                                                     \
}

enum MAZE_PATH {
    EMPTY = 0x0,
    WALL = 0x1,
    EXIT = 0x2,
    SOLUTION = 0x3,
    START = 0x4,
    PARTICLE = 0x5,
};

__device__ void initialize_maze_cuda(MAZE_PATH* maze, int size, int* exit_row, int* exit_col, curandState* localState);
__global__ void init_rng(curandState* state, unsigned long seed);
__global__ void generate_mazes(curandState* globalState, MAZE_PATH* mazes);

__device__ void dfs_maze_generation(MAZE_PATH* maze, int size, int start_row, int start_col, curandState* localState);
__device__ void print_maze_thread(MAZE_PATH* maze, int size);

void print_maze(MAZE_PATH* maze, int size);
void print_maze_debug(MAZE_PATH* maze, int size);

__device__ void print_maze_thread(MAZE_PATH* maze, int size) {
    for (int row = 0; row < size; ++row) {
        for (int col = 0; col < size; ++col) {
            switch (maze[row * size + col]) {
            case MAZE_PATH::EMPTY:
                printf(" ");
                break;
            case MAZE_PATH::WALL:
                printf("#");
                break;
            case MAZE_PATH::EXIT:
                printf("E");
                break;
            case MAZE_PATH::SOLUTION:
                printf(".");
                break;
            case MAZE_PATH::START:
                printf("S");
                break;
            case MAZE_PATH::PARTICLE:
                printf("P");
                break;
            default:
                printf("?");
                break;
            }
            printf(" ");
        }
        printf("\n");
    }
    printf("\n");
}

// Function to print the maze
void print_maze(MAZE_PATH* maze, int size) {
    for (int row = 0; row < size; ++row) {
        for (int col = 0; col < size; ++col) {
            switch (maze[row * size + col]) {
            case MAZE_PATH::EMPTY:
                std::cout << " ";
                break;
            case MAZE_PATH::WALL:
                std::cout << "#";
                break;
            case MAZE_PATH::EXIT:
                std::cout << "E";
                break;
            case MAZE_PATH::SOLUTION:
                std::cout << ".";
                break;
            case MAZE_PATH::START:
                std::cout << "S";
                break;
            case MAZE_PATH::PARTICLE:
                std::cout << "P";
                break;
            default:
                std::cout << "?";
                break;
            }
            std::cout << " ";
        }
        std::cout << std::endl;
    }
}

void print_maze_debug(MAZE_PATH* maze, int size) {
    for (int i = 0; i < size * size; ++i) {
        std::cout << static_cast<int>(maze[i]) << " ";
        if ((i + 1) % size == 0) std::cout << std::endl;
    }
}


// Kernel function to initialize random states
__global__ void init_rng(curandState* state, unsigned long seed) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    curand_init(seed + idx, idx, 0, &state[idx]);

    // Debug print to ensure that initialization happened
    if (idx >= 0) {  // Only print for the first thread to reduce clutter
        printf("curand state initialized for idx = %d\n", idx);
        // Test random number generation
        float random_number = curand_uniform(&state[idx]);
        printf("Random number generated by thread %d: %f\n", idx, random_number);
    }
}

// GPU function to initialize the maze
__device__ void initialize_maze_cuda(MAZE_PATH* maze, int size, int* exit_row, int* exit_col, curandState* localState) {
    for (int row = 0; row < size; ++row) {
        for (int col = 0; col < size; ++col) {
            if (row % 2 == 0 || col % 2 == 0) {
                maze[row * size + col] = MAZE_PATH::WALL;
            }
            else {
                maze[row * size + col] = MAZE_PATH::EMPTY;
            }
        }
    }

    // Randomly choose a border for the exit (0: top/bottom, 1: left/right)
    int border_choice = curand(localState) % 2;

    if (border_choice == 0) {
        *exit_row = (curand(localState) % 2 == 0) ? 0 : size - 1;
        *exit_col = (curand(localState) % (size / 2)) * 2 + 1;
    }
    else {
        *exit_row = (curand(localState) % (size / 2)) * 2 + 1;
        *exit_col = (curand(localState) % 2 == 0) ? 0 : size - 1;
    }

    maze[*exit_row * size + *exit_col] = MAZE_PATH::EXIT;
}

// DFS Maze Generation with Backtracking
__device__ void dfs_maze_generation(MAZE_PATH* maze, int size, int start_row, int start_col, curandState* localState) {
    // Stack-based DFS using explicit stack
    int stack[MAX_SIZE][2]; // Each entry holds (row, col)
    int stack_size = 0;

    bool visited[MAX_SIZE] = { false };
    stack[stack_size][0] = start_row;
    stack[stack_size][1] = start_col;
    visited[start_row * size + start_col] = true;
    stack_size++;

    // Direction vectors for Up, Down, Left, Right
    int direction[4][2] = { {-2, 0}, {2, 0}, {0, -2}, {0, 2} };

    int iteration_count = 0;  // Counter to prevent infinite loops

    while (stack_size > 0) {
        int curr_row = stack[stack_size - 1][0];
        int curr_col = stack[stack_size - 1][1];
        stack_size--;

        int directions_to_try[4] = { 0, 1, 2, 3 };

        // Shuffle directions to introduce randomness
        for (int i = 3; i > 0; --i) {
            int j = curand(localState) % (i + 1);
            int temp = directions_to_try[i];
            directions_to_try[i] = directions_to_try[j];
            directions_to_try[j] = temp;
        }

        bool path_found = false;

        // Explore all possible neighbors in random order
        for (int i = 0; i < 4; ++i) {
            int new_row = curr_row + direction[directions_to_try[i]][0];
            int new_col = curr_col + direction[directions_to_try[i]][1];

            // Ensure we're not moving out of bounds
            if (new_row > 0 && new_row < size - 1 && new_col > 0 && new_col < size - 1) {
                if (!visited[new_row * size + new_col]) {
                    visited[new_row * size + new_col] = true;
                    stack[stack_size][0] = new_row;
                    stack[stack_size][1] = new_col;
                    stack_size++;

                    // Remove the wall between the current and new cell
                    int wall_row = (curr_row + new_row) / 2;
                    int wall_col = (curr_col + new_col) / 2;
                    maze[wall_row * size + wall_col] = MAZE_PATH::EMPTY;

                    // Mark the new cell as part of the path
                    maze[new_row * size + new_col] = MAZE_PATH::EMPTY;

                    path_found = true;
                }
            }
        }

        // If no path was found, the cell is dead-end, continue backtracking
        if (!path_found && stack_size > 0) {
            continue;
        }

        iteration_count++;
        if (iteration_count > MAX_SIZE * 10) {
            // Exit if too many iterations to prevent infinite loop
            printf("Thread %d: Exiting after too many iterations\n", blockIdx.x * blockDim.x + threadIdx.x);
            break;
        }

        // Debug: print stack size and position
        //if (blockIdx.x * blockDim.x + threadIdx.x == 0) {
        //    printf("Thread %d, Iteration %d: Stack size %d, Current position (%d, %d)\n",
        //        blockIdx.x * blockDim.x + threadIdx.x, iteration_count, stack_size, curr_row, curr_col);
        //    print_maze_thread(maze, size); // Ensure this function works correctly within device code
        //}
    }
}

// Kernel function to generate individual mazes
__global__ void generate_mazes(curandState* globalState, MAZE_PATH* mazes) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    // Get the random state for this thread
    curandState localState = globalState[idx];

    // Pointer to this thread's maze in the global memory
    MAZE_PATH* maze = &mazes[idx * N * N];

    int exit_row, exit_col;

    // Initialize the maze
    initialize_maze_cuda(maze, N, &exit_row, &exit_col, &localState);

    // Generate the maze paths using DFS with backtracking
    dfs_maze_generation(maze, N, exit_row, exit_col, &localState);

    // Store the updated state back to global memory
    globalState[idx] = localState;
}

int main() {
    int num_mazes = P * P;
    int maze_size = N * N;

    // Allocate memory for the mazes on the GPU
    MAZE_PATH* d_mazes;
    cudaMalloc(&d_mazes, maze_size * num_mazes * sizeof(MAZE_PATH));

    // Allocate memory for RNG states on the GPU
    curandState* d_states;
    cudaMalloc(&d_states, num_mazes * sizeof(curandState));

    // Initialize the RNG states
    init_rng << <P, P >> > (d_states, time(NULL));
    cudaCheckError();

    // Generate the mazes
    generate_mazes << <P, P >> > (d_states, d_mazes);
    cudaCheckError();

    // Copy the mazes back to the host
    MAZE_PATH* h_mazes = (MAZE_PATH*)malloc(maze_size * num_mazes * sizeof(MAZE_PATH));
    cudaMemcpy(h_mazes, d_mazes, maze_size * num_mazes * sizeof(MAZE_PATH), cudaMemcpyDeviceToHost);
    cudaCheckError();

    std::cout << "Mazes generated successfully!" << std::endl;

    // Print the mazes
    for (int i = 0; i < num_mazes; ++i) {
        std::cout << "Maze " << i << std::endl;
        print_maze(h_mazes + i * maze_size, N);
        print_maze_debug(h_mazes + i * maze_size, N);
        std::cout << std::endl;
    }

    // Free resources
    cudaFree(d_mazes);
    cudaFree(d_states);
    free(h_mazes);

    return 0;
}
