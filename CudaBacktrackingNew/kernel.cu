#include <curand_kernel.h>
#include <iostream>

#define N 9  // Size of individual mazes (N x N)
#define P 2  // Number of mazes in one row/column of the large maze
#define MAX_SIZE (N * N)

// (N*P)*(N*P)

#define cudaCheckError() {                               \
    cudaError_t e = cudaGetLastError();                    \
    if (e != cudaSuccess) {                                \
        printf("CUDA Error %s:%d: %s\n", __FILE__, __LINE__, cudaGetErrorString(e)); \
        exit(EXIT_FAILURE);                                \
    }                                                     \
}

enum MAZE_PATH {
    EMPTY = 0x0,
    WALL = 0x1,
    EXIT = 0x2,
    SOLUTION = 0x3,
    START = 0x4,
    PARTICLE = 0x5,
};

// Declaration (if defined later or in another file)
__device__ void initialize_maze_cuda(MAZE_PATH* maze, int size, int* exit_row, int* exit_col, curandState* localState);
__global__ void init_rng(curandState* state, unsigned long seed);
__global__ void generate_mazes(curandState* globalState, MAZE_PATH* mazes);

__device__ void add_walls_to_queue(int* queue, int& queue_size, int x, int y, int size, bool* in_maze);
__device__ void generate_paths_prim_cuda(MAZE_PATH* maze, int size, int* exit_coords, curandState* localState);

void print_maze(MAZE_PATH* maze, int size);
void print_maze_debug(MAZE_PATH* maze, int size);

// Function to print the maze
void print_maze(MAZE_PATH* maze, int size) {
    for (int row = 0; row < size; ++row) {
        for (int col = 0; col < size; ++col) {
            switch (maze[row * size + col]) {
            case MAZE_PATH::EMPTY:
                std::cout << " ";
                break;
            case MAZE_PATH::WALL:
                std::cout << "#";
                break;
            case MAZE_PATH::EXIT:
                std::cout << "E";
                break;
            case MAZE_PATH::SOLUTION:
                std::cout << ".";
                break;
            case MAZE_PATH::START:
                std::cout << "S";
                break;
            case MAZE_PATH::PARTICLE:
                std::cout << "P";
                break;
            default:
                std::cout << "?";
                break;
            }
        }
        std::cout << std::endl;
    }
}

void print_maze_debug(MAZE_PATH* maze, int size) {
    for (int i = 0; i < size * size; ++i) {
        std::cout << static_cast<int>(maze[i]) << " ";
        if ((i + 1) % size == 0) std::cout << std::endl;
    }
}


// Kernel function to initialize random states
__global__ void init_rng(curandState* state, unsigned long seed) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    curand_init(seed, idx, 0, &state[idx]);

    // Debug print to ensure that initialization happened
    if (idx >= 0) {  // Only print for the first thread to reduce clutter
        printf("curand state initialized for idx = %d\n", idx);
        // Test random number generation
        float random_number = curand_uniform(&state[idx]);
        printf("Random number generated by thread %d: %f\n", idx, random_number);
    }
}

// GPU function to initialize the maze
__device__ void initialize_maze_cuda(MAZE_PATH* maze, int size, int* exit_row, int* exit_col, curandState* localState) {
    for (int row = 0; row < size; ++row) {
        for (int col = 0; col < size; ++col) {
            if (row % 2 == 0 || col % 2 == 0) {
                maze[row * size + col] = MAZE_PATH::WALL;
            }
            else {
                maze[row * size + col] = MAZE_PATH::EMPTY;
            }
        }
    }

    // Randomly choose a border for the exit (0: top/bottom, 1: left/right)
    int border_choice = curand(localState) % 2;

    if (border_choice == 0) {
        // Top or bottom border
        *exit_row = (curand(localState) % 2 == 0) ? 0 : size - 1;
        *exit_col = (curand(localState) % (size / 2)) * 2 + 1;
    }
    else {
        // Left or right border
        *exit_row = (curand(localState) % (size / 2)) * 2 + 1;
        *exit_col = (curand(localState) % 2 == 0) ? 0 : size - 1;
    }

    maze[*exit_row * size + *exit_col] = MAZE_PATH::EXIT;
}

// Kernel function to generate individual mazes
__global__ void generate_mazes(curandState* globalState, MAZE_PATH* mazes) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    // Get the random state for this thread
    curandState localState = globalState[idx];

    // Pointer to this thread's maze in the global memory
    MAZE_PATH* maze = &mazes[idx * N * N];

    int exit_row, exit_col;

    // Initialize the maze
    initialize_maze_cuda(maze, N, &exit_row, &exit_col, &localState);

    // Store the updated state back to global memory
    globalState[idx] = localState;
}

int main() {
    int num_mazes = P * P;
    int maze_size = N * N;

    // Allocate memory for the mazes on the GPU
    MAZE_PATH* d_mazes;
    cudaMalloc(&d_mazes, maze_size * num_mazes * sizeof(MAZE_PATH));

    // Allocate memory for RNG states on the GPU
    curandState* d_states;
    cudaMalloc(&d_states, num_mazes * sizeof(curandState));

    // Initialize the RNG states
    init_rng << <P, P >> > (d_states, time(NULL));
    cudaCheckError();

    // Generate the mazes
    generate_mazes << <P, P >> > (d_states, d_mazes);
    cudaCheckError();

    // Copy the mazes back to the host
    MAZE_PATH* h_mazes = (MAZE_PATH*)malloc(maze_size * num_mazes * sizeof(MAZE_PATH));
    cudaMemcpy(h_mazes, d_mazes, maze_size * num_mazes * sizeof(MAZE_PATH), cudaMemcpyDeviceToHost);
    cudaCheckError();

    // Print the mazes
    for (int i = 0; i < num_mazes; ++i) {
        std::cout << "Maze " << i << std::endl;
        print_maze(h_mazes + i * maze_size, N);
        std::cout << std::endl;
    }

    // Free resources
    cudaFree(d_mazes);
    cudaFree(d_states);
    free(h_mazes);

    return 0;
}
